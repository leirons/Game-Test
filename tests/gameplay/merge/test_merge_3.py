# content of test_merge_1.py
# Positive test

import yaml
from pytest_bdd import given, parsers, scenario, then, when

from utils.get_root import get_root



@scenario(
    "merge.feature",
    "Negative test to check the impossibility of merging houses of different lvl",
)
def test_merge_houses():
    pass


EXTRA_TYPES = {"String": str, "List": str}

CONVERTERS = {
    "initial_board": str,
    "result_board": str,
    "user_queue": str,
    "changed_board": str,
    "user_place": str,
}


@given(
    parsers.cfparse(
        "Game board with default preset houses {file:String}", extra_types=EXTRA_TYPES
    ),
    target_fixture="game_board",
)
def game_in_progress(file,load_fixture_data):
    path = get_root(file)
    data = load_fixture_data(path)
    initial_board = data.get("board")

    return {"initial_board": initial_board}


@then(
    parsers.cfparse("User have in board queue {data:List}", extra_types=EXTRA_TYPES),
    target_fixture="user_queue",
)
def user_queue(data):
    raw_data = data[1:-1].split(",")

    data = [int(i) for i in raw_data]
    return {"user_queue": data}


@when(
    parsers.cfparse("User place on {data:List}", extra_types=EXTRA_TYPES),
    target_fixture="change_board",
)
def user_place(data, game_board, user_queue):
    raw_data = data[1:-1].split(",")

    user_place = [int(i) for i in raw_data]
    x, y = user_place
    board = game_board.get("initial_board")

    user_queue = user_queue.get("user_queue")
    board[x][y] = user_queue[3]
    return user_place


@then(
    parsers.cfparse(
        "A new {file:String} should not be generated by user as the result of the merging",
        extra_types=EXTRA_TYPES,
    )
)
def merge_house(change_board, game_board, file, user_queue,load_fixture_data):
    path = get_root(file)
    data = load_fixture_data(path)

    x, y = change_board
    result_board = data.get("board")
    number_of_houses_before = 0
    board = game_board.get("initial_board")
    user_queue = user_queue.get("user_queue")

    for i in board:
        for j in i:
            if j != 0:
                number_of_houses_before = number_of_houses_before + 1
    current_number_of_houses = 0
    for i in result_board:
        for j in i:
            if j != 0:
                current_number_of_houses = current_number_of_houses + 1

    assert board == result_board
    assert result_board[x][y] == user_queue[3]
    assert current_number_of_houses == number_of_houses_before
